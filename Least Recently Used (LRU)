package lru;

import java.util.*;

public class LRU_Page_Replacement {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input number of pages
        System.out.print("Enter number of pages: ");
        int n = sc.nextInt();

        int[] pages = new int[n];
        System.out.println("Enter the page reference string:");
        for (int i = 0; i < n; i++) {
            pages[i] = sc.nextInt();
        }

        // Input number of frames
        System.out.print("Enter number of frames: ");
        int frames = sc.nextInt();

        List<Integer> memory = new ArrayList<>();  // holds current pages
        int pageFaults = 0;

        System.out.println("\n--- LRU Page Replacement Process ---");

        for (int i = 0; i < n; i++) {
            int page = pages[i];

            // Case 1: Page not in memory (Page Fault)
            if (!memory.contains(page)) {
                if (memory.size() == frames) {
                    // Remove least recently used page (first in the list)
                    memory.remove(0);
                }
                memory.add(page);
                pageFaults++;
            } 
            else {
                // Case 2: Page already in memory â€” mark it as most recently used
                memory.remove((Integer) page);
                memory.add(page);
            }

            // Display memory state after each step
            System.out.print("Step " + (i + 1) + " â†’ ");
            for (int p : memory) {
                System.out.print(p + " ");
            }
            System.out.println();
        }

        System.out.println("\nTotal Page Faults = " + pageFaults);
        sc.close();
    }
}

/*
------------------------------------------------------------
ðŸ§  THEORY: LRU (Least Recently Used) Page Replacement Algorithm
------------------------------------------------------------

ðŸ”¹ Definition:
The **LRU (Least Recently Used)** algorithm replaces the page 
that has **not been used for the longest period of time** in the past.

ðŸ”¹ Working:
1. Maintain a list of pages currently in memory.
2. When a page is referenced:
   - If it is already in memory â†’ mark it as most recently used.
   - If not in memory (page fault):
       â€¢ If there is space â†’ add the new page.
       â€¢ If memory is full â†’ remove the **least recently used** page 
         (the one that was used farthest in the past).
3. Continue for all page references.

ðŸ”¹ Advantages:
âœ… Easy to implement using lists or stacks.
âœ… Performs better than FIFO (fewer page faults).

ðŸ”¹ Disadvantages:
âŒ Requires keeping track of usage order.
âŒ More overhead compared to FIFO.

ðŸ”¹ Example:
Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3
Frames: 3
Total Page Faults: 7
------------------------------------------------------------
*/
