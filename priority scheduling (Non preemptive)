package something;

import java.util.Scanner;

/*
------------------------------------------------------------
üß† THEORY: PRIORITY SCHEDULING (NON-PREEMPTIVE)
------------------------------------------------------------

üîπ Definition:
Priority Scheduling is a CPU scheduling algorithm where
each process is assigned a **priority number**.
The CPU is allocated to the process having the **highest priority**
(üëâ higher number = higher priority).

üîπ Working:
1. Processes are sorted based on **arrival time**.
2. At any scheduling point, among all arrived processes,
   the one with the **highest priority value** is selected.
3. That process runs **till completion** (non-preemptive).
4. Once finished, the next highest-priority process runs.

üîπ Characteristics:
- Type: Non-Preemptive
- Basis: Priority (higher number = higher importance)

üîπ Formulas:
    Turnaround Time (TAT) = Completion Time - Arrival Time
    Waiting Time (WT)     = Turnaround Time - Burst Time
    Response Time (RT)    = Start Time - Arrival Time

üîπ Advantages:
‚úÖ Simple and fair to important processes.
‚úÖ Works well when priorities are clearly defined.

üîπ Disadvantages:
‚ùå Starvation for lower-priority processes.
‚ùå Not ideal for time-sensitive systems.

------------------------------------------------------------
*/

public class PriorityNonPreemptive {

    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

        System.out.println("Enter Total Number of Processes:");
        int totalProcesses = in.nextInt();

        int processId[] = new int[totalProcesses];
        int arrivalTime[] = new int[totalProcesses];
        int burstTime[] = new int[totalProcesses];
        int priority[] = new int[totalProcesses];
        int completionTime[] = new int[totalProcesses];
        int turnaroundTime[] = new int[totalProcesses];
        int waitingTime[] = new int[totalProcesses];
        int responseTime[] = new int[totalProcesses];
        int startTime[] = new int[totalProcesses];
        int isCompleted[] = new int[totalProcesses];
        int ganttChart[] = new int[200]; // for Gantt chart order

        // Input
        for (int i = 0; i < totalProcesses; i++) {
            System.out.println("\nEnter details for Process-" + (i + 1) + ":");
            System.out.print("Arrival Time: ");
            arrivalTime[i] = in.nextInt();
            System.out.print("Burst Time: ");
            burstTime[i] = in.nextInt();
            System.out.print("Priority (higher number = higher priority): ");
            priority[i] = in.nextInt();
            processId[i] = i + 1;
            isCompleted[i] = 0;
        }

        int currentTime = 0;
        int completed = 0;
        int gIndex = 0;

        // Priority Scheduling Execution
        while (completed < totalProcesses) {
            int selectedProcess = -1;
            int highestPriority = -1; // since higher number = higher priority

            // Find process with highest priority among arrived
            for (int i = 0; i < totalProcesses; i++) {
                if (arrivalTime[i] <= currentTime && isCompleted[i] == 0) {
                    if (priority[i] > highestPriority) { // changed sign
                        highestPriority = priority[i];
                        selectedProcess = i;
                    } else if (priority[i] == highestPriority) {
                        // if same priority, pick earlier arrival
                        if (selectedProcess == -1 || arrivalTime[i] < arrivalTime[selectedProcess]) {
                            selectedProcess = i;
                        }
                    }
                }
            }

            if (selectedProcess == -1) {
                currentTime++;
                continue;
            }

            // Record first start time (for response time)
            startTime[selectedProcess] = currentTime;
            responseTime[selectedProcess] = startTime[selectedProcess] - arrivalTime[selectedProcess];

            // Add process to Gantt chart (runs till finish)
            for (int t = 0; t < burstTime[selectedProcess]; t++) {
                ganttChart[gIndex++] = processId[selectedProcess];
            }

            // Execute process fully
            currentTime += burstTime[selectedProcess];
            completionTime[selectedProcess] = currentTime;
            turnaroundTime[selectedProcess] = completionTime[selectedProcess] - arrivalTime[selectedProcess];
            waitingTime[selectedProcess] = turnaroundTime[selectedProcess] - burstTime[selectedProcess];

            isCompleted[selectedProcess] = 1;
            completed++;
        }

        // ‚úÖ Print Result Table (Priority first)
        System.out.println("\nPRI\tProcess\tAT\tBT\tCT\tTAT\tWT\tRT");
        for (int i = 0; i < totalProcesses; i++) {
            System.out.println(priority[i] + "\tP" + processId[i] + "\t" + arrivalTime[i] + "\t" + burstTime[i] + "\t"
                    + completionTime[i] + "\t" + turnaroundTime[i] + "\t" + waitingTime[i] + "\t" + responseTime[i]);
        }

        // ‚úÖ Print Gantt Chart (after table)
        System.out.println("\nGantt Chart:");
        for (int i = 0; i < gIndex; i++) {
            System.out.print("P" + ganttChart[i] + " ");
        }
        System.out.println();

        in.close();
    }
}
