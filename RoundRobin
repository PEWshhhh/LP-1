package something;

import java.util.Scanner;

public class RoundRobin {

    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

        System.out.println("Enter Total Number of Processes:");
        int totalProcesses = in.nextInt();

        // renamed for clarity
        int processId[] = new int[totalProcesses];
        int arrivalTime[] = new int[totalProcesses];
        int burstTime[] = new int[totalProcesses];
        int completionTime[] = new int[totalProcesses];
        int turnaroundTime[] = new int[totalProcesses];
        int waitingTime[] = new int[totalProcesses];
        int responseTime[] = new int[totalProcesses];
        int remainingTime[] = new int[totalProcesses];

        int ganttChart[] = new int[1000]; // store Gantt chart process order

        System.out.println("Enter Time Quantum:");
        int timeQuantum = in.nextInt();

        // input processes
        for (int i = 0; i < totalProcesses; i++) {
            System.out.println("Enter Process-" + (i + 1) + " Arrival Time:");
            arrivalTime[i] = in.nextInt();
            System.out.println("Enter Process-" + (i + 1) + " Burst Time:");
            burstTime[i] = in.nextInt();
            processId[i] = i + 1;
            remainingTime[i] = burstTime[i];
            responseTime[i] = -1; // not started yet
        }

        // variables for RR logic
        int currentTime = 0;
        int finishedProcesses = 0;
        int ganttIndex = 0;

        int readyQueue[] = new int[totalProcesses * 5]; // ready queue
        int front = 0, rear = 0;
        int isInQueue[] = new int[totalProcesses]; // mark if already added

        // find first arriving process
        int firstArrival = 9999, firstIndex = -1;
        for (int i = 0; i < totalProcesses; i++) {
            if (arrivalTime[i] < firstArrival) {
                firstArrival = arrivalTime[i];
                firstIndex = i;
            }
        }

        currentTime = arrivalTime[firstIndex];
        readyQueue[rear++] = firstIndex;
        isInQueue[firstIndex] = 1;

        // Round Robin Execution
        while (finishedProcesses < totalProcesses) {

            // if ready queue empty, move time forward
            if (front == rear) {
                currentTime++;
                for (int i = 0; i < totalProcesses; i++) {
                    if (isInQueue[i] == 0 && arrivalTime[i] <= currentTime) {
                        readyQueue[rear++] = i;
                        isInQueue[i] = 1;
                    }
                }
                continue;
            }

            int index = readyQueue[front++]; // get front of queue

            // record first response time
            if (responseTime[index] == -1) {
                responseTime[index] = currentTime - arrivalTime[index];
            }

            // execute for time quantum or remaining burst
            int runTime = Math.min(timeQuantum, remainingTime[index]);
            for (int t = 0; t < runTime; t++) {
                ganttChart[ganttIndex++] = processId[index];
            }

            remainingTime[index] -= runTime;
            currentTime += runTime;

            // add newly arrived processes to queue
            for (int j = 0; j < totalProcesses; j++) {
                if (isInQueue[j] == 0 && arrivalTime[j] <= currentTime) {
                    readyQueue[rear++] = j;
                    isInQueue[j] = 1;
                }
            }

            // if process unfinished, re-add to queue
            if (remainingTime[index] > 0) {
                readyQueue[rear++] = index;
            } else {
                completionTime[index] = currentTime;
                finishedProcesses++;
            }
        }

        // calculate TAT and WT
        for (int i = 0; i < totalProcesses; i++) {
            turnaroundTime[i] = completionTime[i] - arrivalTime[i];
            waitingTime[i] = turnaroundTime[i] - burstTime[i];
        }

        // print time quantum
        System.out.println("\nTime Quantum = " + timeQuantum);

        // print table
        System.out.println("\nProcess\tAT\tBT\tCT\tTAT\tWT\tRT");
        for (int i = 0; i < totalProcesses; i++) {
            System.out.println("P" + processId[i] + "\t" + arrivalTime[i] + "\t" + burstTime[i] + "\t" +
                    completionTime[i] + "\t" + turnaroundTime[i] + "\t" + waitingTime[i] + "\t" + responseTime[i]);
        }

        // print gantt chart after table
        System.out.println("\nGantt Chart:");
        for (int i = 0; i < ganttIndex; i++) {
            System.out.print("P" + ganttChart[i] + " ");
        }
        System.out.println();

        in.close();
    }
}


/*
------------------------------------------------------------
ðŸ§  THEORY: ROUND ROBIN (RR) SCHEDULING ALGORITHM
------------------------------------------------------------

ðŸ”¹ Definition:
Round Robin (RR) is a preemptive CPU scheduling algorithm 
where each process is assigned a fixed time slot called 
the **Time Quantum (TQ)**. The CPU executes each process 
for that time slice in a cyclic order.

ðŸ”¹ Working:
1. All processes are placed in a **ready queue**.
2. The CPU picks the first process and executes it 
   for at most 'time quantum' units.
3. If the process finishes before TQ, it leaves the queue.
4. If not finished, it is sent **to the back of the queue**.
5. The CPU continues this cycle until all processes are done.

ðŸ”¹ Characteristics:
- Type: Preemptive
- Basis: Time Quantum
- Uses Ready Queue
- All processes get equal CPU share

ðŸ”¹ Important Formulas:
    Turnaround Time (TAT) = Completion Time - Arrival Time
    Waiting Time (WT)     = Turnaround Time - Burst Time
    Response Time (RT)    = First Start Time - Arrival Time

ðŸ”¹ Advantages:
âœ… Fair scheduling â€” all processes get equal CPU time.
âœ… Good response for interactive systems.

ðŸ”¹ Disadvantages:
âŒ Higher average waiting time if TQ is large.
âŒ More context switching if TQ is too small.

ðŸ”¹ Example:
Process | AT | BT
P1      | 0  | 5
P2      | 1  | 3
P3      | 2  | 1
P4      | 3  | 2

Time Quantum = 2

Gantt Chart:
P1 P1 P2 P2 P3 P4 P4 P1 P1 P2 P1 P2

------------------------------------------------------------
*/
